# 1、c51语法

## 1.1、头文件

~~~c
#include <reg51.h>			//定义了：端口地址
~~~



## 1.2、sbit

~~~
sbit是定义（特殊功能寄存器）的（位变量）。
bit和sbit都是C51扩展的变量类型。
典型应用是：sbit P0_0=P0^0;//即定义P0_0为P0口的第1位，以便进行位操作。
bit和int char之类的差不多，只不过char=8位, bit=1位而已。
都是变量，编译器在编译过程中分配地址。
~~~



## 1.3、code

> 相当于：常量

![image-20210312161542756](https://gitee.com/sheep-are-flying-in-the-sky/my-picture/raw/master/picture8/image-20210312161542756.png)****



# 2、实战一

> 类似于：Hello World

## 2.1、让一盏小灯亮

### 2.2.1、先上结果图

> 注意：合适（阻值）

<img src="https://gitee.com/sheep-are-flying-in-the-sky/my-picture/raw/master/picture8/image-20210312100037469.png" alt="image-20210312100037469" style="zoom:50%;" />



### 2.2.2、代码

> keil：12HZ， 输出main.hex文件

~~~c
#include <reg51.h>		//包含了各个引脚的地址

//类型sbit, P20变量名， P2^0 P2的第一个地址P2.0
//这就句话：就是给P20绑定一个地址, 也就是（51单片机上P2.0的地址）
sbit P20 = P2^0;	
					
void main(){
	while(1){
		//将该P2.0的值：置位0
		P20 = 0;
	}
}					  	
~~~



## 2.2、51单片机最小系统

~~~
1、51单片机
2、电源地
3、晶振
4、RET
~~~

> 电容：换算公式
>
> 1法拉(F) = 1×10^6微法(μF)
>
> 1微法(μF)=1X10^3纳法(nF)
>
> 1纳法(nF)(μF)= 1×10^3皮法（pF）

<img src="https://gitee.com/sheep-are-flying-in-the-sky/my-picture/raw/master/picture8/image-20210312103752613.png" alt="image-20210312103752613" style="zoom:50%;" />

---



## 2.3、流水灯

~~~
要求：
      编程控制单片机驱动八个led灯花样点亮。点亮方式为重复以下（1）至（4）步。
        （1）先由上至下依次点亮两轮，每次只亮一盏；
        （2） 接着所有灯交错点亮（亮灭亮灭亮灭亮灭）两轮；
        （3）然后由下至上依次点亮两轮，每次只亮一盏；
        （4）最后所有灯全闪全灭两轮。       
~~~

### 2.3.1、结果图

![image-20210312144926489](https://gitee.com/sheep-are-flying-in-the-sky/my-picture/raw/master/picture8/image-20210312144926489.png)

### 2.3.2、代码

~~~c
#include <reg51.h>

char code led[8] = {0xfe, 0xfd, 0xfb, 0xf7, 0xef, 0xdf, 0xbf, 0x7f};

//延时：函数
void delay(int ms){
	int i, j;
	for(i = 0; i < ms; i++){
		for(j = 0; j < 120; j++){}	
	}
}

void main(){		   
	while(1){
	   int i, j;

	   //第一步：先由上至下，点亮两轮， 每次只亮一盏
	   for(i = 0; i < 2; i++){
		   	 for(j = 0; j < 8; j++){
		   	  P2 = led[j];
			  delay(300);
		   	}
	   }

	   //第二步：所有灯交错点亮
	   for(i = 0; i < 2; i++){
	   		P2 = 0xAA;
			delay(600);
			P2 = 0xFF;
			delay(600);
	   }

	   //第三步：由下依次点亮两轮， 每次只亮一盏
	   for(i = 0; i < 2; i++){
	   		for(j = 7; j >= 0; j--){
		   	  P2 = led[j];
			  delay(300);
		   	}
	   }

	   //第四步：全闪、全灭 （进行两轮）
	   for(i = 0; i < 2; i++){
	   		P2 = 0x00;
			delay(600);
			P2 = 0xFF;
			delay(600);	
	   }
	}
}
~~~



### 2.3.3、分析

> 需要：知道char code 存储的是（8位长度的地址）
>
> 0xfe  相当于 P2.7~P2.0  ==>> 1111 1110
>
> 因为，阳极接的是（小灯正）， 所以P2接口，为0时，形成`闭合回路`, 小灯（亮起）





## 2.4、数码管(==共阳==1~8显示)

~~~
共阳数码管：0~F
char code table[]={0xc0,0xf9,0xa4,0xb0,0x99,0x92,0x82,0xf8,0x80,0x90,0x88,0x83,0xc6,0xa1,0x86,0x8e}
~~~



### 2.4.1、数码管：原理图

<img src="https://gitee.com/sheep-are-flying-in-the-sky/my-picture/raw/master/picture8/image-20210312150723705.png" alt="image-20210312150723705" style="zoom: 50%;" />

---

### 2.4.2、运行结果图

<img src="https://gitee.com/sheep-are-flying-in-the-sky/my-picture/raw/master/picture8/image-20210312171353448.png" alt="image-20210312171353448" style="zoom:67%;" />

### 2.4.3、代码

~~~c
#include <reg51.h>

//定义：0~8的P存放的8位数据
char code led[9] = {0xc0, 0xf9, 0xa4, 0xb0, 0x99, 0x92, 0x83, 0xf8, 0x80};


/*
	这是：0~8位数字的（地址）
	1100 0000	:0xc0   -->0
	1111 1001 :0xf9		-->1
	1010 0100 :0xa4		-->2
	
	1011 0000 :0xb0		-->3
	1001 1001 :0x99		-->4
	1001 0010 :0x92		-->5
	1000 0011 :0x83		-->6
	1111 1000 :0xf8		-->7
	1000 0000 :0x80		-->8
	
*/
	
//延迟函数
void delay(unsigned int ms){
	int i, j;
	for(i = 0; i < ms; i++){
		for(j = 0; j < 125; j++);
	}
}
	
void main(){	
	while(1){
		int i;
		
		//通过循环：进行遍历
		for(i = 0; i < 9; i++){
			P2 = led[i];
			delay(500);
		}
	}
}
~~~



## 2.5、（动态==共阴==）数码管

> 共阴数码管表： 0~F

~~~
char code table[]={0x3f,0x06,0x5b,0x4f,0x66,0x6d,0x7d,0x07,0x7f,0x6f,0x77,0x7c,0x39,0x5e,0x79,0x71}
~~~

<img src="https://gitee.com/sheep-are-flying-in-the-sky/my-picture/raw/master/picture8/image-20210312204503126.png" style="zoom:50%;" />

---

### 2.5.1、结果图

![image-20210313161801913](https://gitee.com/sheep-are-flying-in-the-sky/my-picture/raw/master/picture8/image-20210313161801913.png)



### 2.5.2、代码

~~~c
#include <reg51.h>

//阴极（数码管）：段选（显示数字数组： 0到F）
char code led[]={0x3f,0x06,0x5b,0x4f,0x66,0x6d,0x7d,0x07,0x7f,0x6f,0x77,0x7c,0x39,0x5e,0x79,0x71};

//存放：数码管显示数字的（下标）
char cache[8] = {0, 0, 0, 0, 0, 0, 0, 0};

char code bitControl[8] = {0xfe, 0xfd, 0xfb, 0xf7, 0xef, 0xdf, 0xbf, 0x7f};

//用来记录：开关的值，  当control为1时， 则遍历数组， 当为0时， 则显示1~8
sbit control = P1^2;

int num = 0;			//一开始，索引为起始值

//延迟函数
void delay(int ms){
	int i, j;
	for(i = 0; i < ms; i++){
		for(j = 0; j < 125; j++);
	}

}

//将：阴极（数码管）段选（显示数字数组）的下标，存放在cache里面
void tranfer(char a, s, d, f, g, h, j, k){
	cache[0] = a;
	cache[1] = s;
	cache[2] = d;
	cache[3] = f;
	cache[4] = g;
	cache[5] = h;
	cache[6] = j;
	cache[7] = k;
}


//显示：所有晶体管（同时显示1个数字）， 从0~F
/*void show_common(){
		int i;
		P3 = 0x00;			//位选：此时所有晶体管打开
		for(i = 0; i < 16; i++){
				P2 = led[i];
				delay(300);
		}
}

*/


//显示：1~8数字
void show_differ(){
		int i;
		tranfer(1, 2, 3, 4, 5, 6, 7, 8);		//为cache存放
		for(i = 0; i < 8; i++){
			P3 = bitControl[i];		//{0xfe, 0xfd, 0xfb, 0xf7, 0xef, 0xdf, 0xbf, 0x7f};
			P2 = 0x00;
			P2 = led[cache[i]];		//实现：数码管显示  1~8
		}
}

void main(){
	int i;
	while(1){
	
		/*
			当P1.2端口：
						为高电平时： 显示Num数字
						低电平时：保存数字Num， 然后显示（数字） 1~8
		*/
		
		if(control != 0){
			P3 = 0x00;			//位选：此时所有晶体管打开
			for(i = num; i < 16; i++){
						if(control == 0){			
							num = i;			//当control等于0，也就是P1^2  为低电平时， 将当前遍历数字的下标存好
							break;
						}
						P2 = led[i];
						delay(400);
						
						if(i == 15){
							num = 0;
						}
			}

		}else{
			P2 = 0x00;
			
			//用来显示：不同1 ~ 8的数字的函数
			show_differ();
			
			delay(200);
		}

		
	}
}
~~~



### 2.5.3、改进代码

~~~c
#include <reg51.h>
#include <intrins.h>

//阴极（数码管）：段选（显示数字数组： 0到F）
unsigned char code led[]={0x3f,0x06,0x5b,0x4f,0x66,0x6d,0x7d,0x07,0x7f,0x6f,0x77,0x7c,0x39,0x5e,0x79,0x71};


//位选控制：1~8
unsigned char code bitControl[9] = {0xfe,0xfe, 0xfd, 0xfb, 0xf7, 0xef, 0xdf, 0xbf, 0x7f};

//控制端：当P1_2为1时， 显示0~F，  当P1_2为0时， 显示1~8
sbit P1_2 = P1^2;

//延迟函数
void delay(unsigned int ms){
	unsigned int i;
	for(ms; ms > 0; ms--){
		for(i = 124; i > 0; i--);
	}

}

//显示：1~8数字
void show_differ(){
		unsigned int i;
	
		for(i = 1; i < 9; i++){
			P3 = bitControl[i];			//依次选通：位选
			P2 = led[i];						//依次：显示1~8数字
			delay(1);								//延迟
			P3 = 0xFF;							//清屏：所有都不选通
		}
}

void main(){
	unsigned int i;
	unsigned int num = 0;		//作为记录：暂停时， 数码管显示的（数字的下标）
	
	while(1){
		if(P1_2 != 0){				//当P1_2不为0时
			P3 = 0x00;					//让所有位选：选通， 所有的段选（都亮起）
			for(i = num; i < 15; i++){		//遍历：从暂停位置， 起初（因为没有暂停）num=0
				if(P1_2 != 0){		//再次判断：P1_2是否为0， 因为如果为0，需要跳出for循环
						P2 = led[i];	//让数码管：显示0~F数字
						delay(500);		//延时一下
				}else{
						num = i;			//当P1_2为0时， 记录下（当前遍历到0~F数字的索引）
						break;				//跳出遍历循环
				}
				
				num = 0;					//到此处：都没有跳出循环，说明i == 15，那么将i = num = 0开始遍历
			}
		}else{
			show_differ();			//当为P1_2为0时， 显示1~8
		}
	}
}
~~~





## 2.6、矩阵

### 2.6.1、单个按钮预热

> 这个程序：亮点在于（去抖动）借助于一个flag标志位，而不使用（延时）

<img src="https://gitee.com/sheep-are-flying-in-the-sky/my-picture/raw/master/picture8/image-20210321210215052.png" alt="image-20210321210215052" style="zoom:50%;" />

---

~~~c
#include <reg51.h>
#define uchar unsigned char
#define uint unsigned int
	
uchar num = 0;
uchar flag = 0;
sbit key_P20 = P2^0;

//阴极（数码管）：段选（显示数字数组： 0到9）
uchar led[]={0x3f,0x06,0x5b,0x4f,0x66,0x6d,0x7d,0x07,0x7f,0x6f};

//按键的：函数
void key(){
	if(key_P20 == 0 && flag == 0){		
		flag = 1;
	}
	if(key_P20 == 1 && flag == 1){
		num++;
		flag = 0;
	}
}

//数码管的函数
void seg(){
	P3 = led[num];
	
	if(num == 10){
		num = 0;
	}
}

void main(void){
	while(1){
		key();
		seg();
	}
}
~~~



### 2.6.2、15个按钮：选中

`矩阵键盘2`

<img src="https://gitee.com/sheep-are-flying-in-the-sky/my-picture/raw/master/picture8/image-20210322083551932.png" alt="image-20210322083551932" style="zoom: 33%;" />

~~~c
#include <reg51.h>
#define uint unsigned int
#define uchar unsigned char
	
//阴极（数码管）：段选（显示数字数组： 0到F）
uchar code led[]={0x3f,0x06,0x5b,0x4f,0x66,0x6d,0x7d,0x07,0x7f,0x6f,0x77,0x7c,0x39,0x5e,0x79,0x71};
uchar num = 99;
uchar location[] = {0xee, 0xed, 0xeb, 0xe7,
										0xde, 0xdd, 0xdb, 0xd7,
										0xbe, 0xbd, 0xbb, 0xb7, 
										0x7e, 0x7d, 0x7b, 0x77, 
};

void delay(uint ms){
	uint i;
	for(ms; ms > 0; ms--){
		for(i = 124; i > 0; i--){
		
		}
	}
}

void key_scan(){
	uchar temp=0, temp1=0, temp2;			//存储：x, y的中间变量
	uchar i;
	
	P2 = 0xf0;
	if(P2 != 0xf0){
		delay(20);			//消陡
		temp1 = P2;
		
		P2 = 0x0f;
		if(P2 != 0x0f){
			temp2 = P2;
		}
	}
	
	temp = temp1 + temp2;
//	if(temp == 0xee){
//		num = 0;
//	}
//	
//	if(temp == 0xed){
//		num = 1;
//	}

//	if(temp == 0xeb){
//		num = 2;
//	}
//	
//	if(temp == 0xe7){
//		num = 3;
//	}
//	
//	if(temp == 0xde){
//		num = 4;
//	}
	
	for(i = 0; i < 16; i++){
				if(temp == location[i]){
				  num = i;
				}
		}
}

void display(){
	P3 = led[num];
}

void main(){
	while(1){
		key_scan();			//检测按键是否：被按下
		display();			//显示
	}
}
~~~



### 2.6.3、版本一

<img src="https://gitee.com/sheep-are-flying-in-the-sky/my-picture/raw/master/picture8/image-20210322214922121.png" alt="image-20210322214922121" style="zoom: 33%;" />

~~~c
#include <reg51.h>
#define uint unsigned int
#define uchar unsigned char
	
//阴极（数码管）：段选（显示数字数组： 0到F）
uchar code led[]={0x3f,0x06,0x5b,0x4f,0x66,0x6d,0x7d,0x07,0x7f,0x6f,0x77,0x7c,0x39,0x5e,0x79,0x71};
uchar num;
uchar count = 7;
uchar flag = 0;


uchar array_num[8] = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00,0x00, 0x00};
//位选控制：1~8
uchar bitControl[8] = {0xfe, 0xfd, 0xfb, 0xf7, 0xef, 0xdf, 0xbf, 0x7f};


uchar location[] = {0xee, 0xed, 0xeb, 0xe7,
										0xde, 0xdd, 0xdb, 0xd7,
										0xbe, 0xbd, 0xbb, 0xb7, 
										0x7e, 0x7d, 0x7b, 0x77, 
};

sbit P1_2 = P1^2;


void delay(uint ms){
	uint i;
	for(ms; ms > 0; ms--){
		for(i = 124; i > 0; i--){
		
		}
	}
}

void key_scan(){
	uchar temp=0, temp1=0, temp2;			//存储：x, y的中间变量
	uchar i = 0, j=0;
	
	P2 = 0xf0;
	if(P2 != 0xf0){
		delay(20);			//消陡
		temp1 = P2;
		
		P2 = 0x0f;
		if(P2 != 0x0f){
			temp2 = P2;
		}
	}
	
	temp = temp1 + temp2;
	
	for(i = 0; i < 16; i++){
				if(temp == location[i]){
				  num = i;
					
					if(array_num[7] != 0x00){
						for(j = 0; j < 7; j++){
							array_num[j] = array_num[j+1];
						}
					}
					delay(100);
					array_num[7] = led[i]; 
					delay(100);
				}
		}
}

void display(){
	P3 = 0x00;			//清屏
	P0 = 0x00;			//限选：全部打开
	delay(10);
	//P3 = led[num];
	P3 = array_num[7];
}

//显示：1~8数字
void show_differ(){
		unsigned int i;	
	
		for(i = 0; i < 8; i++){
			P0 = bitControl[i];			//依次选通：位选
			P3 = array_num[i];			//依次：显示1~8数字
			delay(1);								//延迟
			P0 = 0xFF;							//清屏：所有都不选通
		}
}


void main(){
	while(1){
		key_scan();			//检测按键是否：被按下
		
		if(P1_2 == 1){
			P3 = 0x00;		//清屏
			display();
		}else{
			P3 = 0x00;		//清屏
			show_differ();
		}
	}
}
~~~



### 2.6.4、版本二

~~~c
#include <reg51.h>
#define uint unsigned int
#define uchar unsigned char
	
//1、阴极（数码管）：段选（显示数字数组： 0到F）
uchar code led[]={0x3f,0x06,0x5b,0x4f,0x66,0x6d,0x7d,0x07,0x7f,0x6f,0x77,0x7c,0x39,0x5e,0x79,0x71};


//2、位选控制：1~8
uchar code bitControl[8] = {0xfe, 0xfd, 0xfb, 0xf7, 0xef, 0xdf, 0xbf, 0x7f};

//3、记录：显示管，低电平（显示的数组值）的地址
uchar array_num[8] = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00,0x00, 0x00};

//4、用于存放：选中的按钮的（地址）
uchar location[] = {0xee, 0xed, 0xeb, 0xe7,
										0xde, 0xdd, 0xdb, 0xd7,
										0xbe, 0xbd, 0xbb, 0xb7, 
										0x7e, 0x7d, 0x7b, 0x77, 
};

//5、用于存放：当前按钮（按下）显示的
uchar num;
uchar count = 7;
uchar flag = 0;

//6、作为：控制端， 当为1时（显示相同数字）， 当为0时，显示（数组中的数字）
sbit P1_2 = P1^2;

//7、延时函数
void delay(uint ms){
	uint i;
	for(ms; ms > 0; ms--){
		for(i = 124; i > 0; i--){
		
		}
	}
}


//8、将按下数字：存放入数组
void add_array(){
		uchar j;
	
		if(array_num[7] != 0x00){
			for(j = 0; j < 7; j++){
				array_num[j] = array_num[j+1];
				}
		}
		
		delay(100);
		array_num[7] = led[num]; 
		delay(100);
}


//9、扫描（按键按下的数字）
void key_scan(){
	uchar temp=0, temp1=0, temp2;			//存储：x, y的中间变量
	uchar i = 0, j=0;
	
	P2 = 0xf0;
	if(P2 != 0xf0){
		delay(20);			//消陡
		temp1 = P2;
		
		P2 = 0x0f;
		if(P2 != 0x0f){
			temp2 = P2;
		}
	}
	
	temp = temp1 + temp2;
	
	for(i = 0; i < 16; i++){
				if(temp == location[i]){
				  num = i;
					
					delay(10);
					//将该数字：添加到数组中
					add_array();
				}
		}
}

//10、显示相同数字
void display(){
	P3 = 0x00;			//清屏
	P0 = 0x00;			//限选：全部打开
	delay(10);
	P3 = array_num[7];
}

//11、显示：1~8数字
void show_differ(){
		unsigned int i;	
	
		for(i = 0; i < 8; i++){
			P0 = bitControl[i];			//依次选通：位选
			P3 = array_num[i];			//依次：显示1~8数字
			delay(1);								//延迟
			P0 = 0xFF;							//清屏：所有都不选通
		}
}

//12、主函数
void main(){
	while(1){
		key_scan();			//检测按键是否：被按下
		
		if(P1_2 == 1){
			P3 = 0x00;		//清屏
			display();
		}else{
			P3 = 0x00;		//清屏
			show_differ();
		}
	}
}
~~~



### 2.6.5、版本三

~~~c
#include <reg51.h>
#define uint unsigned int
#define uchar unsigned char
	
//1、阴极（数码管）：段选（显示数字数组： 0到F）
uchar code led[]={0x3f,0x06,0x5b,0x4f,0x66,0x6d,0x7d,0x07,0x7f,0x6f,0x77,0x7c,0x39,0x5e,0x79,0x71};


//2、位选控制：1~8
uchar code bitControl[8] = {0xfe, 0xfd, 0xfb, 0xf7, 0xef, 0xdf, 0xbf, 0x7f};

//3、记录：显示管，低电平（显示的数组值）的地址
uchar array_num[8] = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00,0x00, 0x00};

//4、用于存放：选中的按钮的（地址）
uchar location[] = {0xee, 0xed, 0xeb, 0xe7,
										0xde, 0xdd, 0xdb, 0xd7,
										0xbe, 0xbd, 0xbb, 0xb7, 
										0x7e, 0x7d, 0x7b, 0x77, 
};

//5、用于存放：当前按钮（按下）显示的
uchar num;
uchar count = 7;
uchar flag = 0;

//6、作为：控制端， 当为1时（显示相同数字）， 当为0时，显示（数组中的数字）
sbit P1_2 = P1^2;

//7、延时函数
void delay(uint ms){
	uint i;
	for(ms; ms > 0; ms--){
		for(i = 124; i > 0; i--){
				
		}
	}
}


//8、将按下数字：存放入数组
void add_array(){
		uchar j;			
	
		//数组从最后一个元素开始存放，当最后一个(已存放时， 那么数组整体内容右移)
		if(array_num[7] != 0x00){			
			for(j = 0; j < 7; j++){
					array_num[j] = array_num[j+1];
				}
		}
		
		delay(100);									//前后延迟，避免出现（按一下，出现多个数字的情况）
		array_num[7] = led[num]; 
		delay(100);
}


//9、扫描（按键按下的数字）
void key_scan(){
	//temp (存放矩阵上，某个具体地址), temp1（存放矩阵：行地址），temp2存放（列地址）
	uchar temp=0, temp1=0, temp2=0;			
	uchar i = 0, j=0;										//
	
	
	//行：锁定
	P2 = 0xf0;
	if(P2 != 0xf0){
		delay(10);						//行判断：前面消陡
		
		if(P2 != 0xf0)
			temp1 = P2;
		
		delay(10);						//行判断：消陡
		while(P2 == 0xf0);		//如果：P2 == 0xf0将一直卡在这里
	}	
		
	//列：锁定
	P2 = 0x0f;
	if(P2 != 0x0f){
		delay(10);						//前面消陡
		
		if(P2 != 0x0f){				
			temp2 = P2;
		}
		
		delay(10);						//后面消陡
		while(P2 == 0x0f);
	}
	
	//此时：正式获得一个（按下的地址）
	temp = temp1 + temp2;
	
	//如果地址：满足（自我规定的0~F中的一个则处理）
	for(i = 0; i < 16; i++){
				if(temp == location[i]){
				  num = i;
					
					delay(10);
					//将该数字：添加到数组中
					add_array();
				}
		}
}

//10、显示相同数字
void display(){
	P3 = 0x00;			//清屏
	P0 = 0x00;			//限选：全部打开
	delay(10);
	P3 = array_num[7];
}

//11、显示：1~8数字
void show_differ(){
		unsigned int i;	
	
		for(i = 0; i < 8; i++){
			P0 = bitControl[i];			//依次选通：位选
			P3 = array_num[i];			//依次：显示1~8数字
			delay(1);								//延迟
			P0 = 0xFF;							//清屏：所有都不选通
		}
}

//12、主函数
void main(){
	while(1){
		key_scan();			//检测按键是否：被按下
		
		if(P1_2 == 1){
			P3 = 0x00;		//清屏
			display();
		}else{
			P3 = 0x00;		//清屏
			show_differ();
		}
	}
}
~~~



## 2.7、定时计数器

### 2.7.1、原理

<img src="https://gitee.com/sheep-are-flying-in-the-sky/my-picture/raw/master/picture8/image-20210329183135640.png" alt="image-20210329183135640" style="zoom: 67%;" />

----

<img src="https://gitee.com/sheep-are-flying-in-the-sky/my-picture/raw/master/picture9/image-20210405194158348.png" alt="image-20210405194158348" style="zoom:50%;" />

---

<img src="https://gitee.com/sheep-are-flying-in-the-sky/my-picture/raw/master/picture9/image-20210405195945950.png" alt="image-20210405195945950" style="zoom:50%;" />

---

<img src="https://gitee.com/sheep-are-flying-in-the-sky/my-picture/raw/master/picture9/image-20210405200504499.png" alt="image-20210405200504499" style="zoom:50%;" />

---

<img src="https://gitee.com/sheep-are-flying-in-the-sky/my-picture/raw/master/picture9/image-20210405200723147.png" alt="image-20210405200723147" style="zoom:50%;" />

----





### 2.7.2、定时器

> 实现操作：每隔1s，数码管自动加1 （显示）0~9

`1、电路图`

<img src="https://gitee.com/sheep-are-flying-in-the-sky/my-picture/raw/master/picture9/image-20210405211333922.png" alt="image-20210405211333922" style="zoom:50%;" />

----

`2、代码`

~~~c
#include <reg51.h>

unsigned char code led[]={0x3f,0x06,0x5b,0x4f,0x66,0x6d,0x7d,0x07,0x7f,0x6f,0x77,0x7c,0x39,0x5e,0x79,0x71};
unsigned char count = 0;
unsigned char num = 0;

//初始化：定时器
void initTimer(){
	//高4位是定时器1， 低4位是定时器0; GATE = 0, C/T = 0, M1 = 0, M0 = 1; 16进制
	TMOD = 0x01;		
	
	//50ms == 50000us
	//16进制定时/计数方式;  X = 65536 - N/(12/fosc)
	TH0 = (65536-50000)/256;			//取高8位
	TL0 = (65536-50000)%256;			//取低8位
    EA = 1;		//开启总中断
	ET0 = 1;	//开启定时器0的中断
	TR0 = 1;	//启动定时器0
	
}

void delay(unsigned int ms){
	int j;
	for(ms; ms > 0; ms--){
		for(j = 124; j > 0; j--);
	}
}

void display(){
	P2 = led[num];
	if(num == 10){
		num = 0;
	}
	
}

void main(){
	initTimer();
	while(1){
		display();
	}
}

//功能号： 0（外部中断0）， 1（定时器中断0）， 2（外部中断1）， 3（定时器中断1）， 4（串口中断）
void inte_Time0() interrupt 1{
		TH0 = (65536-50000)/256;			//取高4位
		TL0 = (65536-50000)%256;			//取低4位
		count++;
	
		//因为：之前是50ms中断一次， 速度过快，将其放大20倍，1s进行中断1次
		//也就是：count 起初计数1次50ms, 现在计数20次，便是1s
		if(count == 20){
			num++;
			count = 0;
		}
}
~~~

### 2.7.3、计数器

`1、开启注意点`

> N为：计数的次数

<img src="https://gitee.com/sheep-are-flying-in-the-sky/my-picture/raw/master/picture9/image-20210405212025403.png" alt="image-20210405212025403" style="zoom:33%;" />

---

`2、效果图`

<img src="https://gitee.com/sheep-are-flying-in-the-sky/my-picture/raw/master/picture9/image-20210405220751270.png" alt="image-20210405220751270" style="zoom:50%;" />

---

`3、代码`

~~~c
/*
	 测试：计数器， 每按3次按钮，数码管值：加1
*/

#include <reg51.h>

unsigned char count = 0;
unsigned char code led[]={0x3f,0x06,0x5b,0x4f,0x66,0x6d,0x7d,0x07,0x7f,0x6f,0x77,0x7c,0x39,0x5e,0x79,0x71};



//计数器
void init_Count(){
	//GATE = 0; C/T = 1; M1 = 1; M0 = 0; 八位自动重置定时/计数器
	
	TMOD = 0x6;		//0000 0110
	TH0 = 256-3;	//高位：256-N   每3次，计数一次，因为8位能容纳256，所以高低为值一样
	TL0 = 256-3;	//低位	
	EA = 1;				//总中断打开
	ET0 = 1;			//计数器/定时器 （端口）：打开
	TR0 = 1;			//定时器/计数器 （启动位）：1为启动	
}


//计数器/定时器中断0：为功能号1
void inte_Counter() interrupt 1{
	count++;
}


//显示函数
void display(){
	P2 = led[count];
	if(count == 10){
		count = 0;
	}
}

void main(){
	init_Count();			//初始化计数器	
	
	while(1){
		display();			//显示
	}
}
~~~













## 2.8、外部中断

### 2.8.1、原理

---

<img src="https://gitee.com/sheep-are-flying-in-the-sky/my-picture/raw/master/picture8/image-20210329193115166.png" alt="image-20210329193115166" style="zoom:50%;" />

---

<img src="https://gitee.com/sheep-are-flying-in-the-sky/my-picture/raw/master/picture8/image-20210329184315990.png" alt="image-20210329184315990" style="zoom: 50%;" />

---

<img src="https://gitee.com/sheep-are-flying-in-the-sky/my-picture/raw/master/picture8/image-20210329184340479.png" alt="image-20210329184340479" style="zoom: 50%;" />

---

<img src="https://gitee.com/sheep-are-flying-in-the-sky/my-picture/raw/master/picture8/image-20210329184550137.png" alt="image-20210329184550137" style="zoom:50%;" />

---

<img src="https://gitee.com/sheep-are-flying-in-the-sky/my-picture/raw/master/picture8/image-20210329184647843.png" alt="image-20210329184647843" style="zoom:50%;" />

---

![image-20210329184920277](https://gitee.com/sheep-are-flying-in-the-sky/my-picture/raw/master/picture8/image-20210329184920277.png)

---



### 2.8.2、7段数码管点亮

- `1、电路图`

<img src="https://gitee.com/sheep-are-flying-in-the-sky/my-picture/raw/master/picture8/image-20210329195419054.png" alt="image-20210329195419054" style="zoom:50%;" />

- `2、代码`

~~~c
#include <reg51.h>

//共阴极数码管
char code table[]={0x3f,0x06,0x5b,0x4f,0x66,0x6d,0x7d,0x07,0x7f,0x6f,0x77,0x7c,0x39,0x5e,0x79,0x71};
unsigned char num = 0;
sbit ex = P3^2;

void initex(){
	EA = 1;				//开启总中断
	EX0 = 1;			//外部中断INT0的中断允许位
	IT0 = 1;			//使用：边沿触发
}

void display(){
	P2 = table[num];
	
	if(num == 10){
		num = 0;
	}
}

void main(){
	ex = 1;
	initex();
	
	
	while(1){
		display();
	}
}

void ex_isr() interrupt 0		//外部中断0： 功能号
{
	num++;
}
~~~





### 2.8.3、跑马灯

`1、电路图`

<img src="https://gitee.com/sheep-are-flying-in-the-sky/my-picture/raw/master/picture8/image-20210329214125805.png" alt="image-20210329214125805" style="zoom:50%;" />

`2、代码`

~~~c
#include <reg51.h>

unsigned char code led[8] = {0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80};

//初始化：中断服务
void init_inter_ser(){
	EA = 1;				//开启总中断
	EX0 = 1;			//外部中断INT0的中断允许位
	EX1 = 1;			//外部中断INT1的中断允许位
	IT0 = 1;			//使用：边沿触发
	
	PX1 = 1;			//设置：PX1的优先级为高 （默认的INT0 高于 INT1）
}

//延时：函数
void delay(unsigned int ms){
	unsigned int j;
	for(ms; ms > 0; ms--){
		for(j = 124; j > 0; j--){
		
		}
	}
}


//(按钮一)中断：交替点亮
void interrupt_Button1() interrupt 0
{
		unsigned char i;
		 //所有灯交错点（偶数亮完， 奇数亮）	
	   for(i = 0; i < 3; i++){
				P2 = 0xAA;
				delay(300);
				P2 = 0x55;
				delay(300);
	   }
}

//（按钮二）中断：从下往上点亮
void interrupt_Button2() interrupt 2
{	
			char i;
		 //所有灯交错点（偶数亮完， 奇数亮）	
	   for(i = 7; i >= 0; i--){
				P2 = led[i];
			  delay(200);
	   }
}


void main(){		   
	//初始化：中断服务
	init_inter_ser();
	
	while(1){
	  unsigned char i = 0;			//作为循环变量
		
		for(i = 0; i < 8; i++){
			P2 = led[i];
			delay(200);
		}
		
	}
}
~~~





### 2.8.4、出租车记数仪

`1、电路图`

<img src="https://gitee.com/sheep-are-flying-in-the-sky/my-picture/raw/master/picture9/image-20210406192021299.png" alt="image-20210406192021299" style="zoom: 50%;" />

---

`2、代码`

~~~c
#include <reg51.h>

//记录阴极数码管：0~9
unsigned char code led[]={0x3f,0x06,0x5b,0x4f,0x66,0x6d,0x7d,0x07,0x7f,0x6f};

//位选控制：1~6
unsigned char code bitControl[] = {0xfe, 0xfd, 0xfb, 0xf7, 0xef, 0xdf};

//数码管：计数最终值（下标）
unsigned char a[] = {0, 0, 0, 0, 0, 0};

//count值：0（全灭）; 1(数码管全部为0); 2(开始计数); 3(暂停计数，显示累加和); 4(关闭仪器,全灭)
unsigned char count = 0;			

//记录：累加值， 每次加4
unsigned int sum = 0;			


//1、初始化：中断服务
void init_inter_ser(){
	EA = 1;				//开启总中断
	EX0 = 1;			//外部中断INT0的中断允许位
	EX1 = 1;			//外部中断INT1的中断允许位
	IT0 = 1;			//使用：边沿触发
	IT1 = 1;			//使用：边沿触发
	
	PX1 = 1;			//设置：PX1的优先级为高 （默认的INT0 高于 INT1）
}

//延时：函数
void delay(unsigned int ms){
	unsigned int j;
	for(ms; ms > 0; ms--){
		for(j = 124; j > 0; j--);
	}
}


//中断1: 外部中断0
void interrupt_Button1() interrupt 0
{
		//当count == 2说明 （计时器：开始计数）
		if(count == 2){
			sum += 4;
		}
}	


//中断2: 外部中断1
void interrupt_Button2() interrupt 2
{
		//点击一次按钮：count + 1
		count++;
}



//2、开始计数 (count == 2)
void begin_count(){
		unsigned char i;										//循环变量
		unsigned char index = 5;						//索引值
		unsigned int temp = sum;						//将计数器不停加+4的值： 存放到temp
	
		/*将计数值分割（十万位、万位、千位、 百位、十位、个位）
				对应存放到(  a[0]、 a[1]、 a[2]、a[3]、a[4]、a[5])
		*/    
		while (temp) {
	    a[index--] = temp%10;	
	    temp /= 10;
		}	
		
	
		for(i = 0; i < 6; i++){
			P2 = bitControl[i];			//依次选通：位选
			P0 = led[a[i]];					//依次：显示1~8数字
			delay(1);								//延迟
			P2 = 0xFF;							//清屏：所有都不选通
		}
}


//3、显示：最终计数值（count == 3）
void final_result(){
		unsigned char int i;  			//临时变量
		for(i = 0; i < 6; i++){
				P2 = bitControl[i];			//依次选通：位选
				P0 = led[a[i]];					//依次：显示1~8数字
				delay(1);								//延迟
				P2 = 0xFF;							//清屏：所有都不选通
		}
}

//4、重置：回到初始状态（count == 4）
void reset(){
		unsigned char i;				//i 作为循环变量
		count = 0;							//count 按钮值（清0）, count == 0 为关闭状态
		sum = 0;								//计数值（清0）					
		for(i = 0; i < 6; i++){	
			a[i] = 0;							//数组值（十万、万、千、百、十、个）位， 也清零
		}
}


void main(){		   
	//1、初始化：中断服务
	init_inter_ser();
	
	while(1){
		switch(count){
			case 0: 
				P2 = 0xFF;										break;					//段选（全部关闭）	 
			
			case 1:
				P0 = led[0];  P2 = 0x00; 			break;					//段选（全部打开）
			
			case 2:	
				//2、开始计数 (count == 2)
				begin_count();								break;					
			
			case 3:	
				//3、显示：最终计数值（count == 3）
				final_result();								break;					
				
			case 4:		
				//4、重置：回到初始状态（count == 4）
				reset();											break;					
		}
	}	
}
~~~







## 2.9、秒表

`1、电路图`

<img src="https://gitee.com/sheep-are-flying-in-the-sky/my-picture/raw/master/picture9/image-20210407191547996.png" alt="image-20210407191547996" style="zoom: 50%;" />

---

`2、代码`

~~~c
#include <reg51.h>

unsigned char code led[]={0x3f,0x06,0x5b,0x4f,0x66,0x6d,0x7d,0x07,0x7f,0x6f,0x77,0x7c,0x39,0x5e,0x79,0x71};
unsigned char count = 0;
unsigned char num = 0;
unsigned char n = 0;
unsigned char button = 0;			//0黑屏， 1启动、2停止和   3复位
sbit p1_7 = P1^7;

//1、初始化：定时器、及外部中断0
void initTimer(){
	//高4位是定时器1， 低4位是定时器0; GATE = 0, C/T = 0, M1 = 0, M0 = 1; 16进制
	TMOD = 0x01;		
	
	//50ms == 50000us
	//16进制定时/计数方式;  X = 65536 - N/(12/fosc)
	TH0 = (65536-50000)/256;			//取高8位
	TL0 = (65536-50000)%256;			//取低8位
	
	ET0 = 1;	//开启定时器0的中断
	EA = 1;		//开启总中断
	//TR0 = 1;	//启动定时器0
	
	
	
	EX0 = 1;			//外部中断INT0的中断允许位
	IT0 = 1;			//使用：边沿触发
}


//2、显示函数
void display(){
	P1 = led[n];
	P2 = led[num];
	if(num == 10){
		n++;
		num = 0;
	}
	
	if(n == 10){
		n = 0;
	}
	
}


//功能号： 0（外部中断0）， 1（定时器中断0）， 2（外部中断1）， 3（定时器中断1）， 4（串口中断）
void inte_Time0() interrupt 1{
		TH0 = (65536-50000)/256;			//取高8位
		TL0 = (65536-50000)%256;			//取低8位
		count++;
	
		//因为：之前是50ms中断一次， 速度过快，将其放大2倍，0.1s进行中断1次
		//也就是：count 起初计数1次50ms, 现在计数2次，便是0.1s
		if(count == 2){
			num++;
			count = 0;
		}
}


//中断1: 外部中断0
void interrupt_Button1() interrupt 0
{
		button++;
}	

//重置
void reset(){
			button = 0;										
			count = 0;
			num = 0;
			n = 0;
			p1_7 = 1;		//关闭小数点
}


void main(){
	P0 = 0x00;
	initTimer();
	
	while(1){
		switch(button){
			case 0: 			//黑屏 (button == 0)
				P1 = 0x00;
				P2 = 0x00;										break;	
			
			case 1:				//启动(button == 1)
				TR0 = 1;	  //启动定时器0
				p1_7 = 1;		//打开小数点
				display(); 										break;					
			
			case 2:				//停止(button == 2)
				
				TR0 = 0;	 	//关闭定时器
				p1_7 = 1;											break;			
			
			case 3:				//重置(button == 3)
				reset();
																			break;	
		}
	}
}


~~~



## 2.10、蜂鸣器

### 2.10.1、前置知识

> 频率 （和）周期  换算

![image-20210413195525126](https://gitee.com/sheep-are-flying-in-the-sky/my-picture/raw/master/picture9/image-20210413195525126.png)



### 2.10.2、第一个跑起来

> 电路图

![image-20210413210715530](https://gitee.com/sheep-are-flying-in-the-sky/my-picture/raw/master/picture9/image-20210413210715530.png)

> 代码

~~~c
#include <reg51.h>

sbit Sound = P3^7;

//延迟函数
void delay(unsigned int ms){
	unsigned int i;
	for(ms; ms > 0; ms--){
		for(i = 124; i > 0; i--);
	}

}


void main(void){
	unsigned char i;
	
	while(1){
		
		for(i = 0; i < 50; i++){
			Sound = ~Sound;
			delay(1);		
		}
		
		for(i = 0; i < 100; i++){
			Sound = ~Sound;
			delay(2);		
		}
	}
}
~~~



### 2.10.3、工具音乐转换

> 地址：http://news.eeworld.com.cn/mcu/article_2016090729180.html





# 3、实战二

## 3.1、播放简单音乐

### 3.1.1、电路图

![image-20210413210715530](https://gitee.com/sheep-are-flying-in-the-sky/my-picture/raw/master/picture9/image-20210413210715530.png)



### 3.1.2、代码

> 参考：http://news.eeworld.com.cn/mcu/article_2016090729180.html

~~~c
#ifndef __SOUNDPLAY_H_REVISION_FIRST__ 
#define __SOUNDPLAY_H_REVISION_FIRST__ 
#include  <reg51.h>
//************************************************************************** 
#define SYSTEM_OSC 11059200//12000000 //定义晶振频率12000000HZ 
#define SOUND_SPACE 4/5 //定义普通音符演奏的长度分率,//每4分音符间隔 
sbit BeepIO = P3^7; //定义输出管脚 
unsigned int code FreTab[12] = { 262,277,294,311,330,349,369,392,415,440,466,494 }; //原始频率表 
unsigned char code SignTab[7] = { 0,2,4,5,7,9,11 }; //1~7在频率表中的位置 
unsigned char code LengthTab[7]= { 1,2,4,8,16,32,64 }; 
unsigned char Sound_Temp_TH0,Sound_Temp_TL0; //音符定时器初值暂存 
unsigned char Sound_Temp_TH1,Sound_Temp_TL1; //音长定时器初值暂存 
//************************************************************************** 
void InitialSound(void) 
{ 
BeepIO = 1; 
Sound_Temp_TH1 = (65535-(1/1200)*SYSTEM_OSC)/256; // 计算TL1应装入的初值 (10ms的初装值) 
Sound_Temp_TL1 = (65535-(1/1200)*SYSTEM_OSC)%256; // 计算TH1应装入的初值 
TH1 = Sound_Temp_TH1; 
TL1 = Sound_Temp_TL1; 
TMOD |= 0x11; 
ET0 = 1; 
ET1 = 0; 
TR0 = 0; 
TR1 = 0; 
EA = 1; 
} 
void BeepTimer0(void) interrupt 1 //音符发生中断 
{ 
BeepIO = !BeepIO; 
TH0 = Sound_Temp_TH0; 
TL0 = Sound_Temp_TL0; 
} 
//************************************************************************** 
void Play(unsigned char *Sound,unsigned char Signature,unsigned Octachord,unsigned int Speed) 
{ 
unsigned int NewFreTab[12]; //新的频率表 
unsigned char i,j; 
unsigned int Point,LDiv,LDiv0,LDiv1,LDiv2,LDiv4,CurrentFre,Temp_T,SoundLength; 
unsigned char Tone,Length,SL,SH,SM,SLen,XG,FD; 
for(i=0;i<12;i++) // 根据调号及升降八度来生成新的频率表 
{ 
j = i + Signature; 
if(j > 11) 
{ 
j = j-12; 
NewFreTab[i] = FreTab[j]*2; 
} 
else 
NewFreTab[i] = FreTab[j]; 
if(Octachord == 1) 
NewFreTab[i]>>=2; 
else if(Octachord == 3) 
NewFreTab[i]<<=2; 
} 
SoundLength = 0; 
while(Sound[SoundLength] != 0x00) //计算歌曲长度 
{ 
SoundLength+=2; 
} 
Point = 0; 
Tone = Sound[Point]; 
Length = Sound[Point+1]; // 读出第一个音符和它时时值 
LDiv0 = 12000/Speed; // 算出1分音符的长度(几个10ms) 
LDiv4 = LDiv0/4; // 算出4分音符的长度 
LDiv4 = LDiv4-LDiv4*SOUND_SPACE; // 普通音最长间隔标准 
TR0 = 0; 
TR1 = 1; 
while(Point < SoundLength) 
{ 
SL=Tone%10; //计算出音符 
SM=Tone/10%10; //计算出高低音 
SH=Tone/100; //计算出是否升半 
CurrentFre = NewFreTab[SignTab[SL-1]+SH]; //查出对应音符的频率 
if(SL!=0) 
{ 
if (SM==1) CurrentFre >>= 2; //低音 
if (SM==3) CurrentFre <<= 2; //高音 
Temp_T = 65536-(50000/CurrentFre)*10/(12000000/SYSTEM_OSC);//计算计数器初值 
Sound_Temp_TH0 = Temp_T/256; 
Sound_Temp_TL0 = Temp_T%256; 
TH0 = Sound_Temp_TH0; 
TL0 = Sound_Temp_TL0 + 12; //加12是对中断延时的补偿 
} 
SLen=LengthTab[Length%10]; //算出是几分音符 
XG=Length/10%10; //算出音符类型(0普通1连音2顿音) 
FD=Length/100; 
LDiv=LDiv0/SLen; //算出连音音符演奏的长度(多少个10ms) 
if (FD==1) 
LDiv=LDiv+LDiv/2; 
if(XG!=1) 
if(XG==0) //算出普通音符的演奏长度 
if (SLen<=4) 
LDiv1=LDiv-LDiv4; 
else 
LDiv1=LDiv*SOUND_SPACE; 
else 
LDiv1=LDiv/2; //算出顿音的演奏长度 
else 
LDiv1=LDiv; 
if(SL==0) LDiv1=0; 
LDiv2=LDiv-LDiv1; //算出不发音的长度 
if (SL!=0) 
{ 
TR0=1; 
for(i=LDiv1;i>0;i--) //发规定长度的音 
{ 
while(TF1==0); 
TH1 = Sound_Temp_TH1; 
TL1 = Sound_Temp_TL1; 
TF1=0; 
} 
} 
if(LDiv2!=0) 
{ 
TR0=0; BeepIO=1; 
for(i=LDiv2;i>0;i--) //音符间的间隔 
{ 
while(TF1==0); 
TH1 = Sound_Temp_TH1; 
TL1 = Sound_Temp_TL1; 
TF1=0; 
} 
} 
Point+=2; 
Tone=Sound[Point]; 
Length=Sound[Point+1]; 
} 
BeepIO = 1; 
} 
//************************************************************************** 
#endif 
//挥着翅膀的女孩 
unsigned char code Music_Girl[]={ 0x17,0x02, 0x17,0x03, 0x18,0x03, 0x19,0x02, 0x15,0x03, 
0x16,0x03, 0x17,0x03, 0x17,0x03, 0x17,0x03, 0x18,0x03, 
0x19,0x02, 0x16,0x03, 0x17,0x03, 0x18,0x02, 0x18,0x03, 
0x17,0x03, 0x15,0x02, 0x18,0x03, 0x17,0x03, 0x18,0x02, 
0x10,0x03, 0x15,0x03, 0x16,0x02, 0x15,0x03, 0x16,0x03, 
0x17,0x02, 0x17,0x03, 0x18,0x03, 0x19,0x02, 0x1A,0x03, 
0x1B,0x03, 0x1F,0x03, 0x1F,0x03, 0x17,0x03, 0x18,0x03, 
0x19,0x02, 0x16,0x03, 0x17,0x03, 0x18,0x03, 0x17,0x03, 
0x18,0x03, 0x1F,0x03, 0x1F,0x02, 0x16,0x03, 0x17,0x03, 
0x18,0x03, 0x17,0x03, 0x18,0x03, 0x20,0x03, 0x20,0x02, 
0x1F,0x03, 0x1B,0x03, 0x1F,0x66, 0x20,0x03, 0x21,0x03, 
0x20,0x03, 0x1F,0x03, 0x1B,0x03, 0x1F,0x66, 0x1F,0x03, 
0x1B,0x03, 0x19,0x03, 0x19,0x03, 0x15,0x03, 0x1A,0x66, 
0x1A,0x03, 0x19,0x03, 0x15,0x03, 0x15,0x03, 0x17,0x03, 
0x16,0x66, 0x17,0x04, 0x18,0x04, 0x18,0x03, 0x19,0x03, 
0x1F,0x03, 0x1B,0x03, 0x1F,0x66, 0x20,0x03, 0x21,0x03, 
0x20,0x03, 0x1F,0x03, 0x1B,0x03, 0x1F,0x66, 0x1F,0x03, 
0x1B,0x03, 0x19,0x03, 0x19,0x03, 0x15,0x03, 0x1A,0x66, 
0x1A,0x03, 0x19,0x03, 0x19,0x03, 0x1F,0x03, 0x1B,0x03, 
0x1F,0x00, 0x1A,0x03, 0x1A,0x03, 0x1A,0x03, 0x1B,0x03, 
0x1B,0x03, 0x1A,0x03, 0x19,0x03, 0x19,0x02, 0x17,0x03, 
0x15,0x17, 0x15,0x03, 0x16,0x03, 0x17,0x03, 0x18,0x03, 
0x17,0x04, 0x18,0x0E, 0x18,0x03, 0x17,0x04, 0x18,0x0E, 
0x18,0x66, 0x17,0x03, 0x18,0x03, 0x17,0x03, 0x18,0x03, 
0x20,0x03, 0x20,0x02, 0x1F,0x03, 0x1B,0x03, 0x1F,0x66, 
0x20,0x03, 0x21,0x03, 0x20,0x03, 0x1F,0x03, 0x1B,0x03, 
0x1F,0x66, 0x1F,0x04, 0x1B,0x0E, 0x1B,0x03, 0x19,0x03, 
0x19,0x03, 0x15,0x03, 0x1A,0x66, 0x1A,0x03, 0x19,0x03, 
0x15,0x03, 0x15,0x03, 0x17,0x03, 0x16,0x66, 0x17,0x04, 
0x18,0x04, 0x18,0x03, 0x19,0x03, 0x1F,0x03, 0x1B,0x03, 
0x1F,0x66, 0x20,0x03, 0x21,0x03, 0x20,0x03, 0x1F,0x03, 
0x1B,0x03, 0x1F,0x66, 0x1F,0x03, 0x1B,0x03, 0x19,0x03, 
0x19,0x03, 0x15,0x03, 0x1A,0x66, 0x1A,0x03, 0x19,0x03, 
0x19,0x03, 0x1F,0x03, 0x1B,0x03, 0x1F,0x00, 0x18,0x02, 
0x18,0x03, 0x1A,0x03, 0x19,0x0D, 0x15,0x03, 0x15,0x02, 
0x18,0x66, 0x16,0x02, 0x17,0x02, 0x15,0x00, 0x00,0x00}; 
//同一首歌 
unsigned char code Music_Same[]={ 0x0F,0x01, 0x15,0x02, 0x16,0x02, 0x17,0x66, 0x18,0x03, 
0x17,0x02, 0x15,0x02, 0x16,0x01, 0x15,0x02, 0x10,0x02, 
0x15,0x00, 0x0F,0x01, 0x15,0x02, 0x16,0x02, 0x17,0x02, 
0x17,0x03, 0x18,0x03, 0x19,0x02, 0x15,0x02, 0x18,0x66, 
0x17,0x03, 0x19,0x02, 0x16,0x03, 0x17,0x03, 0x16,0x00, 
0x17,0x01, 0x19,0x02, 0x1B,0x02, 0x1B,0x70, 0x1A,0x03, 
0x1A,0x01, 0x19,0x02, 0x19,0x03, 0x1A,0x03, 0x1B,0x02, 
0x1A,0x0D, 0x19,0x03, 0x17,0x00, 0x18,0x66, 0x18,0x03, 
0x19,0x02, 0x1A,0x02, 0x19,0x0C, 0x18,0x0D, 0x17,0x03, 
0x16,0x01, 0x11,0x02, 0x11,0x03, 0x10,0x03, 0x0F,0x0C, 
0x10,0x02, 0x15,0x00, 0x1F,0x01, 0x1A,0x01, 0x18,0x66, 
0x19,0x03, 0x1A,0x01, 0x1B,0x02, 0x1B,0x03, 0x1B,0x03, 
0x1B,0x0C, 0x1A,0x0D, 0x19,0x03, 0x17,0x00, 0x1F,0x01, 
0x1A,0x01, 0x18,0x66, 0x19,0x03, 0x1A,0x01, 0x10,0x02, 
0x10,0x03, 0x10,0x03, 0x1A,0x0C, 0x18,0x0D, 0x17,0x03, 
0x16,0x00, 0x0F,0x01, 0x15,0x02, 0x16,0x02, 0x17,0x70, 
0x18,0x03, 0x17,0x02, 0x15,0x03, 0x15,0x03, 0x16,0x66, 
0x16,0x03, 0x16,0x02, 0x16,0x03, 0x15,0x03, 0x10,0x02, 
0x10,0x01, 0x11,0x01, 0x11,0x66, 0x10,0x03, 0x0F,0x0C, 
0x1A,0x02, 0x19,0x02, 0x16,0x03, 0x16,0x03, 0x18,0x66, 
0x18,0x03, 0x18,0x02, 0x17,0x03, 0x16,0x03, 0x19,0x00, 
0x00,0x00 }; 
//两只蝴蝶 
unsigned char code Music_Two[] ={ 0x17,0x03, 0x16,0x03, 0x17,0x01, 0x16,0x03, 0x17,0x03, 
0x16,0x03, 0x15,0x01, 0x10,0x03, 0x15,0x03, 0x16,0x02, 
0x16,0x0D, 0x17,0x03, 0x16,0x03, 0x15,0x03, 0x10,0x03, 
0x10,0x0E, 0x15,0x04, 0x0F,0x01, 0x17,0x03, 0x16,0x03, 
0x17,0x01, 0x16,0x03, 0x17,0x03, 0x16,0x03, 0x15,0x01, 
0x10,0x03, 0x15,0x03, 0x16,0x02, 0x16,0x0D, 0x17,0x03, 
0x16,0x03, 0x15,0x03, 0x10,0x03, 0x15,0x03, 0x16,0x01, 
0x17,0x03, 0x16,0x03, 0x17,0x01, 0x16,0x03, 0x17,0x03, 
0x16,0x03, 0x15,0x01, 0x10,0x03, 0x15,0x03, 0x16,0x02, 
0x16,0x0D, 0x17,0x03, 0x16,0x03, 0x15,0x03, 0x10,0x03, 
0x10,0x0E, 0x15,0x04, 0x0F,0x01, 0x17,0x03, 0x19,0x03, 
0x19,0x01, 0x19,0x03, 0x1A,0x03, 0x19,0x03, 0x17,0x01, 
0x16,0x03, 0x16,0x03, 0x16,0x02, 0x16,0x0D, 0x17,0x03, 
0x16,0x03, 0x15,0x03, 0x10,0x03, 0x10,0x0D, 0x15,0x00, 
0x19,0x03, 0x19,0x03, 0x1A,0x03, 0x1F,0x03, 0x1B,0x03, 
0x1B,0x03, 0x1A,0x03, 0x17,0x0D, 0x16,0x03, 0x16,0x03, 
0x16,0x0D, 0x17,0x01, 0x17,0x03, 0x17,0x03, 0x19,0x03, 
0x1A,0x02, 0x1A,0x02, 0x10,0x03, 0x17,0x0D, 0x16,0x03, 
0x16,0x01, 0x17,0x03, 0x19,0x03, 0x19,0x03, 0x17,0x03, 
0x19,0x02, 0x1F,0x02, 0x1B,0x03, 0x1A,0x03, 0x1A,0x0E, 
0x1B,0x04, 0x17,0x02, 0x1A,0x03, 0x1A,0x03, 0x1A,0x0E, 
0x1B,0x04, 0x1A,0x03, 0x19,0x03, 0x17,0x03, 0x16,0x03, 
0x17,0x0D, 0x16,0x03, 0x17,0x03, 0x19,0x01, 0x19,0x03, 
0x19,0x03, 0x1A,0x03, 0x1F,0x03, 0x1B,0x03, 0x1B,0x03, 
0x1A,0x03, 0x17,0x0D, 0x16,0x03, 0x16,0x03, 0x16,0x03, 
0x17,0x01, 0x17,0x03, 0x17,0x03, 0x19,0x03, 0x1A,0x02, 
0x1A,0x02, 0x10,0x03, 0x17,0x0D, 0x16,0x03, 0x16,0x01, 
0x17,0x03, 0x19,0x03, 0x19,0x03, 0x17,0x03, 0x19,0x03, 
0x1F,0x02, 0x1B,0x03, 0x1A,0x03, 0x1A,0x0E, 0x1B,0x04, 
0x17,0x02, 0x1A,0x03, 0x1A,0x03, 0x1A,0x0E, 0x1B,0x04, 
0x17,0x16, 0x1A,0x03, 0x1A,0x03, 0x1A,0x0E, 0x1B,0x04, 
0x1A,0x03, 0x19,0x03, 0x17,0x03, 0x16,0x03, 0x0F,0x02, 
0x10,0x03, 0x15,0x00, 0x00,0x00 }; 
void main() 
{ 
    InitialSound(); 
    while(1) 
    { 
        //Play(Music_Girl,0,2,350); 
        //Play(Music_Same,0,2,350); 
        Play(Music_Two,0,2,350); 
    } 
} 
~~~

