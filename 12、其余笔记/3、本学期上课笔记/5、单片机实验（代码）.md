# 1、c51语法

## 1.1、头文件

~~~c
#include <reg51.h>			//定义了：端口地址
~~~



## 1.2、sbit

~~~
sbit是定义（特殊功能寄存器）的（位变量）。
bit和sbit都是C51扩展的变量类型。
典型应用是：sbit P0_0=P0^0;//即定义P0_0为P0口的第1位，以便进行位操作。
bit和int char之类的差不多，只不过char=8位, bit=1位而已。
都是变量，编译器在编译过程中分配地址。
~~~



## 1.3、code

> 相当于：常量

![image-20210312161542756](https://gitee.com/sheep-are-flying-in-the-sky/my-picture/raw/master/picture8/image-20210312161542756.png)****



# 2、实战

> 类似于：Hello World

## 2.1、让一盏小灯亮

### 2.2.1、先上结果图

> 注意：合适（阻值）

<img src="https://gitee.com/sheep-are-flying-in-the-sky/my-picture/raw/master/picture8/image-20210312100037469.png" alt="image-20210312100037469" style="zoom:50%;" />



### 2.2.2、代码

> keil：12HZ， 输出main.hex文件

~~~c
#include <reg51.h>		//包含了各个引脚的地址

//类型sbit, P20变量名， P2^0 P2的第一个地址P2.0
//这就句话：就是给P20绑定一个地址, 也就是（51单片机上P2.0的地址）
sbit P20 = P2^0;	
					
void main(){
	while(1){
		//将该P2.0的值：置位0
		P20 = 0;
	}
}					  	
~~~



## 2.2、51单片机最小系统

~~~
1、51单片机
2、电源地
3、晶振
4、RET
~~~

> 电容：换算公式
>
> 1法拉(F) = 1×10^6微法(μF)
>
> 1微法(μF)=1X10^3纳法(nF)
>
> 1纳法(nF)(μF)= 1×10^3皮法（pF）

<img src="https://gitee.com/sheep-are-flying-in-the-sky/my-picture/raw/master/picture8/image-20210312103752613.png" alt="image-20210312103752613" style="zoom:50%;" />

---



## 2.3、流水灯

~~~
要求：
      编程控制单片机驱动八个led灯花样点亮。点亮方式为重复以下（1）至（4）步。
        （1）先由上至下依次点亮两轮，每次只亮一盏；
        （2） 接着所有灯交错点亮（亮灭亮灭亮灭亮灭）两轮；
        （3）然后由下至上依次点亮两轮，每次只亮一盏；
        （4）最后所有灯全闪全灭两轮。       
~~~

### 2.3.1、结果图

![image-20210312144926489](https://gitee.com/sheep-are-flying-in-the-sky/my-picture/raw/master/picture8/image-20210312144926489.png)

### 2.3.2、代码

~~~c
#include <reg51.h>

char code led[8] = {0xfe, 0xfd, 0xfb, 0xf7, 0xef, 0xdf, 0xbf, 0x7f};

//延时：函数
void delay(int ms){
	int i, j;
	for(i = 0; i < ms; i++){
		for(j = 0; j < 120; j++){}	
	}
}

void main(){		   
	while(1){
	   int i, j;

	   //第一步：先由上至下，点亮两轮， 每次只亮一盏
	   for(i = 0; i < 2; i++){
		   	 for(j = 0; j < 8; j++){
		   	  P2 = led[j];
			  delay(300);
		   	}
	   }

	   //第二步：所有灯交错点亮
	   for(i = 0; i < 2; i++){
	   		P2 = 0xAA;
			delay(600);
			P2 = 0xFF;
			delay(600);
	   }

	   //第三步：由下依次点亮两轮， 每次只亮一盏
	   for(i = 0; i < 2; i++){
	   		for(j = 7; j >= 0; j--){
		   	  P2 = led[j];
			  delay(300);
		   	}
	   }

	   //第四步：全闪、全灭 （进行两轮）
	   for(i = 0; i < 2; i++){
	   		P2 = 0x00;
			delay(600);
			P2 = 0xFF;
			delay(600);	
	   }
	}
}
~~~



### 2.3.3、分析

> 需要：知道char code 存储的是（8位长度的地址）
>
> 0xfe  相当于 P2.7~P2.0  ==>> 1111 1110
>
> 因为，阳极接的是（小灯正）， 所以P2接口，为0时，形成`闭合回路`, 小灯（亮起）





## 2.4、数码管(==共阳==1~8显示)

~~~
共阳数码管：0~F
char code table[]={0xc0,0xf9,0xa4,0xb0,0x99,0x92,0x82,0xf8,0x80,0x90,0x88,0x83,0xc6,0xa1,0x86,0x8e}
~~~



### 2.4.1、数码管：原理图

<img src="https://gitee.com/sheep-are-flying-in-the-sky/my-picture/raw/master/picture8/image-20210312150723705.png" alt="image-20210312150723705" style="zoom: 50%;" />

---

### 2.4.2、运行结果图

<img src="https://gitee.com/sheep-are-flying-in-the-sky/my-picture/raw/master/picture8/image-20210312171353448.png" alt="image-20210312171353448" style="zoom:67%;" />

### 2.4.3、代码

~~~c
#include <reg51.h>

//定义：0~8的P存放的8位数据
char code led[9] = {0xc0, 0xf9, 0xa4, 0xb0, 0x99, 0x92, 0x83, 0xf8, 0x80};


/*
	这是：0~8位数字的（地址）
	1100 0000	:0xc0   -->0
	1111 1001 :0xf9		-->1
	1010 0100 :0xa4		-->2
	
	1011 0000 :0xb0		-->3
	1001 1001 :0x99		-->4
	1001 0010 :0x92		-->5
	1000 0011 :0x83		-->6
	1111 1000 :0xf8		-->7
	1000 0000 :0x80		-->8
	
*/
	
//延迟函数
void delay(unsigned int ms){
	int i, j;
	for(i = 0; i < ms; i++){
		for(j = 0; j < 125; j++);
	}
}
	
void main(){	
	while(1){
		int i;
		
		//通过循环：进行遍历
		for(i = 0; i < 9; i++){
			P2 = led[i];
			delay(500);
		}
	}
}
~~~



## 2.5、（动态==共阴==）数码管

> 共阴数码管表： 0~F

~~~
char code table[]={0x3f,0x06,0x5b,0x4f,0x66,0x6d,0x7d,0x07,0x7f,0x6f,0x77,0x7c,0x39,0x5e,0x79,0x71}
~~~

<img src="https://gitee.com/sheep-are-flying-in-the-sky/my-picture/raw/master/picture8/image-20210312204503126.png" style="zoom:50%;" />

---

### 2.5.1、结果图

![image-20210313161801913](https://gitee.com/sheep-are-flying-in-the-sky/my-picture/raw/master/picture8/image-20210313161801913.png)



### 2.5.2、代码

~~~c
#include <reg51.h>

//阴极（数码管）：段选（显示数字数组： 0到F）
char code led[]={0x3f,0x06,0x5b,0x4f,0x66,0x6d,0x7d,0x07,0x7f,0x6f,0x77,0x7c,0x39,0x5e,0x79,0x71};

//存放：数码管显示数字的（下标）
char cache[8] = {0, 0, 0, 0, 0, 0, 0, 0};

char code bitControl[8] = {0xfe, 0xfd, 0xfb, 0xf7, 0xef, 0xdf, 0xbf, 0x7f};

//用来记录：开关的值，  当control为1时， 则遍历数组， 当为0时， 则显示1~8
sbit control = P1^2;

int num = 0;			//一开始，索引为起始值

//延迟函数
void delay(int ms){
	int i, j;
	for(i = 0; i < ms; i++){
		for(j = 0; j < 125; j++);
	}

}

//将：阴极（数码管）段选（显示数字数组）的下标，存放在cache里面
void tranfer(char a, s, d, f, g, h, j, k){
	cache[0] = a;
	cache[1] = s;
	cache[2] = d;
	cache[3] = f;
	cache[4] = g;
	cache[5] = h;
	cache[6] = j;
	cache[7] = k;
}


//显示：所有晶体管（同时显示1个数字）， 从0~F
/*void show_common(){
		int i;
		P3 = 0x00;			//位选：此时所有晶体管打开
		for(i = 0; i < 16; i++){
				P2 = led[i];
				delay(300);
		}
}

*/


//显示：1~8数字
void show_differ(){
		int i;
		tranfer(1, 2, 3, 4, 5, 6, 7, 8);		//为cache存放
		for(i = 0; i < 8; i++){
			P3 = bitControl[i];		//{0xfe, 0xfd, 0xfb, 0xf7, 0xef, 0xdf, 0xbf, 0x7f};
			P2 = 0x00;
			P2 = led[cache[i]];		//实现：数码管显示  1~8
		}
}

void main(){
	int i;
	while(1){
	
		/*
			当P1.2端口：
						为高电平时： 显示Num数字
						低电平时：保存数字Num， 然后显示（数字） 1~8
		*/
		
		if(control != 0){
			P3 = 0x00;			//位选：此时所有晶体管打开
			for(i = num; i < 16; i++){
						if(control == 0){			
							num = i;			//当control等于0，也就是P1^2  为低电平时， 将当前遍历数字的下标存好
							break;
						}
						P2 = led[i];
						delay(400);
						
						if(i == 15){
							num = 0;
						}
			}

		}else{
			P2 = 0x00;
			
			//用来显示：不同1 ~ 8的数字的函数
			show_differ();
			
			delay(200);
		}

		
	}
}
~~~



### 2.5.3、改进代码

~~~c
#include <reg51.h>
#include <intrins.h>

//阴极（数码管）：段选（显示数字数组： 0到F）
unsigned char code led[]={0x3f,0x06,0x5b,0x4f,0x66,0x6d,0x7d,0x07,0x7f,0x6f,0x77,0x7c,0x39,0x5e,0x79,0x71};


//位选控制：1~8
unsigned char code bitControl[9] = {0xfe,0xfe, 0xfd, 0xfb, 0xf7, 0xef, 0xdf, 0xbf, 0x7f};

//控制端：当P1_2为1时， 显示0~F，  当P1_2为0时， 显示1~8
sbit P1_2 = P1^2;

//延迟函数
void delay(unsigned int ms){
	unsigned int i;
	for(ms; ms > 0; ms--){
		for(i = 124; i > 0; i--);
	}

}

//显示：1~8数字
void show_differ(){
		unsigned int i;
	
		for(i = 1; i < 9; i++){
			P3 = bitControl[i];			//依次选通：位选
			P2 = led[i];						//依次：显示1~8数字
			delay(1);								//延迟
			P3 = 0xFF;							//清屏：所有都不选通
		}
}

void main(){
	unsigned int i;
	unsigned int num = 0;		//作为记录：暂停时， 数码管显示的（数字的下标）
	
	while(1){
		if(P1_2 != 0){				//当P1_2不为0时
			P3 = 0x00;					//让所有位选：选通， 所有的段选（都亮起）
			for(i = num; i < 15; i++){		//遍历：从暂停位置， 起初（因为没有暂停）num=0
				if(P1_2 != 0){		//再次判断：P1_2是否为0， 因为如果为0，需要跳出for循环
						P2 = led[i];	//让数码管：显示0~F数字
						delay(500);		//延时一下
				}else{
						num = i;			//当P1_2为0时， 记录下（当前遍历到0~F数字的索引）
						break;				//跳出遍历循环
				}
				
				num = 0;					//到此处：都没有跳出循环，说明i == 15，那么将i = num = 0开始遍历
			}
		}else{
			show_differ();			//当为P1_2为0时， 显示1~8
		}
	}
}
~~~





## 2.6、矩阵

### 2.6.1、单个按钮预热

> 这个程序：亮点在于（去抖动）借助于一个flag标志位，而不使用（延时）

<img src="https://gitee.com/sheep-are-flying-in-the-sky/my-picture/raw/master/picture8/image-20210321210215052.png" alt="image-20210321210215052" style="zoom:50%;" />

---

~~~c
#include <reg51.h>
#define uchar unsigned char
#define uint unsigned int
	
uchar num = 0;
uchar flag = 0;
sbit key_P20 = P2^0;

//阴极（数码管）：段选（显示数字数组： 0到9）
uchar led[]={0x3f,0x06,0x5b,0x4f,0x66,0x6d,0x7d,0x07,0x7f,0x6f};

//按键的：函数
void key(){
	if(key_P20 == 0 && flag == 0){		
		flag = 1;
	}
	if(key_P20 == 1 && flag == 1){
		num++;
		flag = 0;
	}
}

//数码管的函数
void seg(){
	P3 = led[num];
	
	if(num == 10){
		num = 0;
	}
}

void main(void){
	while(1){
		key();
		seg();
	}
}
~~~



### 2.6.2、15个按钮：选中

`矩阵键盘2`

<img src="https://gitee.com/sheep-are-flying-in-the-sky/my-picture/raw/master/picture8/image-20210322083551932.png" alt="image-20210322083551932" style="zoom: 33%;" />

~~~c
#include <reg51.h>
#define uint unsigned int
#define uchar unsigned char
	
//阴极（数码管）：段选（显示数字数组： 0到F）
uchar code led[]={0x3f,0x06,0x5b,0x4f,0x66,0x6d,0x7d,0x07,0x7f,0x6f,0x77,0x7c,0x39,0x5e,0x79,0x71};
uchar num = 99;
uchar location[] = {0xee, 0xed, 0xeb, 0xe7,
										0xde, 0xdd, 0xdb, 0xd7,
										0xbe, 0xbd, 0xbb, 0xb7, 
										0x7e, 0x7d, 0x7b, 0x77, 
};

void delay(uint ms){
	uint i;
	for(ms; ms > 0; ms--){
		for(i = 124; i > 0; i--){
		
		}
	}
}

void key_scan(){
	uchar temp=0, temp1=0, temp2;			//存储：x, y的中间变量
	uchar i;
	
	P2 = 0xf0;
	if(P2 != 0xf0){
		delay(20);			//消陡
		temp1 = P2;
		
		P2 = 0x0f;
		if(P2 != 0x0f){
			temp2 = P2;
		}
	}
	
	temp = temp1 + temp2;
//	if(temp == 0xee){
//		num = 0;
//	}
//	
//	if(temp == 0xed){
//		num = 1;
//	}

//	if(temp == 0xeb){
//		num = 2;
//	}
//	
//	if(temp == 0xe7){
//		num = 3;
//	}
//	
//	if(temp == 0xde){
//		num = 4;
//	}
	
	for(i = 0; i < 16; i++){
				if(temp == location[i]){
				  num = i;
				}
		}
}

void display(){
	P3 = led[num];
}

void main(){
	while(1){
		key_scan();			//检测按键是否：被按下
		display();			//显示
	}
}
~~~



### 2.6.3、版本一

<img src="https://gitee.com/sheep-are-flying-in-the-sky/my-picture/raw/master/picture8/image-20210322214922121.png" alt="image-20210322214922121" style="zoom: 33%;" />

~~~c
#include <reg51.h>
#define uint unsigned int
#define uchar unsigned char
	
//阴极（数码管）：段选（显示数字数组： 0到F）
uchar code led[]={0x3f,0x06,0x5b,0x4f,0x66,0x6d,0x7d,0x07,0x7f,0x6f,0x77,0x7c,0x39,0x5e,0x79,0x71};
uchar num;
uchar count = 7;
uchar flag = 0;


uchar array_num[8] = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00,0x00, 0x00};
//位选控制：1~8
uchar bitControl[8] = {0xfe, 0xfd, 0xfb, 0xf7, 0xef, 0xdf, 0xbf, 0x7f};


uchar location[] = {0xee, 0xed, 0xeb, 0xe7,
										0xde, 0xdd, 0xdb, 0xd7,
										0xbe, 0xbd, 0xbb, 0xb7, 
										0x7e, 0x7d, 0x7b, 0x77, 
};

sbit P1_2 = P1^2;


void delay(uint ms){
	uint i;
	for(ms; ms > 0; ms--){
		for(i = 124; i > 0; i--){
		
		}
	}
}

void key_scan(){
	uchar temp=0, temp1=0, temp2;			//存储：x, y的中间变量
	uchar i = 0, j=0;
	
	P2 = 0xf0;
	if(P2 != 0xf0){
		delay(20);			//消陡
		temp1 = P2;
		
		P2 = 0x0f;
		if(P2 != 0x0f){
			temp2 = P2;
		}
	}
	
	temp = temp1 + temp2;
	
	for(i = 0; i < 16; i++){
				if(temp == location[i]){
				  num = i;
					
					if(array_num[7] != 0x00){
						for(j = 0; j < 7; j++){
							array_num[j] = array_num[j+1];
						}
					}
					delay(100);
					array_num[7] = led[i]; 
					delay(100);
				}
		}
}

void display(){
	P3 = 0x00;			//清屏
	P0 = 0x00;			//限选：全部打开
	delay(10);
	//P3 = led[num];
	P3 = array_num[7];
}

//显示：1~8数字
void show_differ(){
		unsigned int i;	
	
		for(i = 0; i < 8; i++){
			P0 = bitControl[i];			//依次选通：位选
			P3 = array_num[i];			//依次：显示1~8数字
			delay(1);								//延迟
			P0 = 0xFF;							//清屏：所有都不选通
		}
}


void main(){
	while(1){
		key_scan();			//检测按键是否：被按下
		
		if(P1_2 == 1){
			P3 = 0x00;		//清屏
			display();
		}else{
			P3 = 0x00;		//清屏
			show_differ();
		}
	}
}
~~~



### 2.6.4、版本二

~~~c
#include <reg51.h>
#define uint unsigned int
#define uchar unsigned char
	
//1、阴极（数码管）：段选（显示数字数组： 0到F）
uchar code led[]={0x3f,0x06,0x5b,0x4f,0x66,0x6d,0x7d,0x07,0x7f,0x6f,0x77,0x7c,0x39,0x5e,0x79,0x71};


//2、位选控制：1~8
uchar code bitControl[8] = {0xfe, 0xfd, 0xfb, 0xf7, 0xef, 0xdf, 0xbf, 0x7f};

//3、记录：显示管，低电平（显示的数组值）的地址
uchar array_num[8] = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00,0x00, 0x00};

//4、用于存放：选中的按钮的（地址）
uchar location[] = {0xee, 0xed, 0xeb, 0xe7,
										0xde, 0xdd, 0xdb, 0xd7,
										0xbe, 0xbd, 0xbb, 0xb7, 
										0x7e, 0x7d, 0x7b, 0x77, 
};

//5、用于存放：当前按钮（按下）显示的
uchar num;
uchar count = 7;
uchar flag = 0;

//6、作为：控制端， 当为1时（显示相同数字）， 当为0时，显示（数组中的数字）
sbit P1_2 = P1^2;

//7、延时函数
void delay(uint ms){
	uint i;
	for(ms; ms > 0; ms--){
		for(i = 124; i > 0; i--){
		
		}
	}
}


//8、将按下数字：存放入数组
void add_array(){
		uchar j;
	
		if(array_num[7] != 0x00){
			for(j = 0; j < 7; j++){
				array_num[j] = array_num[j+1];
				}
		}
		
		delay(100);
		array_num[7] = led[num]; 
		delay(100);
}


//9、扫描（按键按下的数字）
void key_scan(){
	uchar temp=0, temp1=0, temp2;			//存储：x, y的中间变量
	uchar i = 0, j=0;
	
	P2 = 0xf0;
	if(P2 != 0xf0){
		delay(20);			//消陡
		temp1 = P2;
		
		P2 = 0x0f;
		if(P2 != 0x0f){
			temp2 = P2;
		}
	}
	
	temp = temp1 + temp2;
	
	for(i = 0; i < 16; i++){
				if(temp == location[i]){
				  num = i;
					
					delay(10);
					//将该数字：添加到数组中
					add_array();
				}
		}
}

//10、显示相同数字
void display(){
	P3 = 0x00;			//清屏
	P0 = 0x00;			//限选：全部打开
	delay(10);
	P3 = array_num[7];
}

//11、显示：1~8数字
void show_differ(){
		unsigned int i;	
	
		for(i = 0; i < 8; i++){
			P0 = bitControl[i];			//依次选通：位选
			P3 = array_num[i];			//依次：显示1~8数字
			delay(1);								//延迟
			P0 = 0xFF;							//清屏：所有都不选通
		}
}

//12、主函数
void main(){
	while(1){
		key_scan();			//检测按键是否：被按下
		
		if(P1_2 == 1){
			P3 = 0x00;		//清屏
			display();
		}else{
			P3 = 0x00;		//清屏
			show_differ();
		}
	}
}
~~~



### 2.6.5、版本三

~~~c
#include <reg51.h>
#define uint unsigned int
#define uchar unsigned char
	
//1、阴极（数码管）：段选（显示数字数组： 0到F）
uchar code led[]={0x3f,0x06,0x5b,0x4f,0x66,0x6d,0x7d,0x07,0x7f,0x6f,0x77,0x7c,0x39,0x5e,0x79,0x71};


//2、位选控制：1~8
uchar code bitControl[8] = {0xfe, 0xfd, 0xfb, 0xf7, 0xef, 0xdf, 0xbf, 0x7f};

//3、记录：显示管，低电平（显示的数组值）的地址
uchar array_num[8] = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00,0x00, 0x00};

//4、用于存放：选中的按钮的（地址）
uchar location[] = {0xee, 0xed, 0xeb, 0xe7,
										0xde, 0xdd, 0xdb, 0xd7,
										0xbe, 0xbd, 0xbb, 0xb7, 
										0x7e, 0x7d, 0x7b, 0x77, 
};

//5、用于存放：当前按钮（按下）显示的
uchar num;
uchar count = 7;
uchar flag = 0;

//6、作为：控制端， 当为1时（显示相同数字）， 当为0时，显示（数组中的数字）
sbit P1_2 = P1^2;

//7、延时函数
void delay(uint ms){
	uint i;
	for(ms; ms > 0; ms--){
		for(i = 124; i > 0; i--){
				
		}
	}
}


//8、将按下数字：存放入数组
void add_array(){
		uchar j;			
	
		//数组从最后一个元素开始存放，当最后一个(已存放时， 那么数组整体内容右移)
		if(array_num[7] != 0x00){			
			for(j = 0; j < 7; j++){
					array_num[j] = array_num[j+1];
				}
		}
		
		delay(100);									//前后延迟，避免出现（按一下，出现多个数字的情况）
		array_num[7] = led[num]; 
		delay(100);
}


//9、扫描（按键按下的数字）
void key_scan(){
	//temp (存放矩阵上，某个具体地址), temp1（存放矩阵：行地址），temp2存放（列地址）
	uchar temp=0, temp1=0, temp2=0;			
	uchar i = 0, j=0;										//
	
	
	//行：锁定
	P2 = 0xf0;
	if(P2 != 0xf0){
		delay(10);						//行判断：前面消陡
		
		if(P2 != 0xf0)
			temp1 = P2;
		
		delay(10);						//行判断：消陡
		while(P2 == 0xf0);		//如果：P2 == 0xf0将一直卡在这里
	}	
		
	//列：锁定
	P2 = 0x0f;
	if(P2 != 0x0f){
		delay(10);						//前面消陡
		
		if(P2 != 0x0f){				
			temp2 = P2;
		}
		
		delay(10);						//后面消陡
		while(P2 == 0x0f);
	}
	
	//此时：正式获得一个（按下的地址）
	temp = temp1 + temp2;
	
	//如果地址：满足（自我规定的0~F中的一个则处理）
	for(i = 0; i < 16; i++){
				if(temp == location[i]){
				  num = i;
					
					delay(10);
					//将该数字：添加到数组中
					add_array();
				}
		}
}

//10、显示相同数字
void display(){
	P3 = 0x00;			//清屏
	P0 = 0x00;			//限选：全部打开
	delay(10);
	P3 = array_num[7];
}

//11、显示：1~8数字
void show_differ(){
		unsigned int i;	
	
		for(i = 0; i < 8; i++){
			P0 = bitControl[i];			//依次选通：位选
			P3 = array_num[i];			//依次：显示1~8数字
			delay(1);								//延迟
			P0 = 0xFF;							//清屏：所有都不选通
		}
}

//12、主函数
void main(){
	while(1){
		key_scan();			//检测按键是否：被按下
		
		if(P1_2 == 1){
			P3 = 0x00;		//清屏
			display();
		}else{
			P3 = 0x00;		//清屏
			show_differ();
		}
	}
}
~~~

