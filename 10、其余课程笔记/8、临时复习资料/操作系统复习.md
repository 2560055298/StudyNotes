~~~
（一）题型及分数比例
	1、单项选择题、填空题、是非题（40%）
	2、词解释题，简述题（20%）
	3、综合题，包括算法题、计算题等（40%）
~~~

# 一颗星

## 1.1、单道批处理系统、多道批处理系统

~~~

~~~



## 1.2、进程调度

~~~

~~~



## 1.3、利用银行家算法避免死锁

~~~

~~~



## 1.4、信号量机制

~~~

~~~



## 1.5、中断处理程序

~~~

~~~



## 1.6、文件操作

~~~

~~~



## 1.7、索引文件

~~~

~~~



## 1.8、虚拟存储器概述

~~~

~~~



## 1.9、操作系统的基本特性

~~~

~~~



# 两颗星

## 2.1、生产者消费者问题

~~~
最后弄：花1个半小时，背下来
~~~

![image-20210112101139344](https://gitee.com/sheep-are-flying-in-the-sky/my-picture/raw/master/picture6/image-20210112101139344.png)

## 2.2、操作系统的作用（必背）

~~~
记忆方法：两个作为， 一个实现

（1）OS （作为用户）与（计算机硬件系统）之间的接口
（2）OS 作为（计算机系统资源）的（管理者）
（3）OS （实现）了对（计算机资源）的抽象
~~~

==拓展一下==

<img src="https://gitee.com/sheep-are-flying-in-the-sky/my-picture/raw/master/picture6/image-20210111203455777.png" alt="image-20210111203455777" style="zoom:50%;" />

## 2.3、死锁相关（银行家解决）

~~~
一、死锁的概念
	如果（一组进程）中的（每一个进程）都在（等待）仅由（该组进程中）的（其它进程）（才能引发）的	  事件，那么（该组进程）是死锁的。

二、产生死锁的原因
	记忆法：两竞争， 一推进
	1、竞争不可抢占性资源。
	2、竞争可消耗资源。
		如打印机，公用队列其数目不足以满足诸进程的需要时，会引起诸进程对资源的竞争而产生死锁。
	3、进程推进顺序不当。
	
三、产生死锁的四个必要条件：
	1、互斥条件：一个资源每次只能被一个进程使用。
	2、请求和保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放。
	3、不可抢占条件:进程已获得的资源，在末使用完之前，不能强行剥夺只能在进程使用完时由自己放。
	4、循环等待条件:若干进程之间形成一种头尾相接的循环等待资源关系。
	
四、解决死锁的基本方法
	1、预防死锁：
	   （1）破坏“互斥”条件
			一次性分配所有资源，这样就不会再有请求了：（破坏请求条件）
       （2）破坏“请求和保持”条件
        	只要有一个资源得不到分配，也不给这个进程分配其他的资源：（破坏请保持条件）
        	
       （3）破坏“不可抢占”条件：
       		允许对资源实行抢夺。即当某进程获得了部分资源，但得不到其它资源，则释放已占有的资							 源（破坏不可剥夺条件）
       （4）破坏“循环等待”条件：系统给每类资源赋予一个编号，每一个进程按编号递增的顺序请求资								源，释放则相反（破坏环路等待条件）
	2、避免死锁:（银行家算法）
		（1）安全状态：指按某种（进程推进顺序p1,p2...pn）,为每个进程分配所需资源，直至满足						 每个进程的（最大要求），处于安全状态则不会进入死锁。
		
		（2）不安全状态，就是找不到这样一个（进程推进）序列， 但是不安全（不代表）就一定会死锁
		
		（3）避免死锁的实质是：
			系统在进行资源分配时，应使系统不进入不安全状态。
		
		（4）公式必记：
			可用资源 >= 最大需要资源 - 已分配资源
			那么，融合当前进程序列后， 可用资源 == 上一次可用资源 + 上一次已分配资源
			
		
	3、检测死锁
		首先为每个进程和每个资源指定一个唯一的号码；
		然后建立资源分配表和进程等待表。
	4、解除死锁:
		当发现有进程死锁后，便应立即把它从死锁状态中解脱出来，常采用的方法有：
		剥夺资源：从其它进程剥夺足够数量的资源给死锁进程，以解除死锁状态；
		撤消进程：可以直接撤消死锁进程或撤消代价最小的进程，直至有足够的资源可用，死锁状态.消除		为止；所谓代价是指优先级、运行代价、进程的重要性和价值等。
~~~

- (Dijkstra）银行家数据结构

~~~
数据结构：
	1、可利用资源向量：Available
		是一个含有m个元素的数组， 每一个元素代表（某一类资源的：可利用数目）
		例如：Aailable[j] = K, 表示系统现有Rj类资源， K个
	
	2、最大需求矩阵：Max
		是一个n * m矩阵， 代表有n个进程，每一个进程对m类资源的（最大需求）
		例如：Max[i, j] = K, 表示进程i需要Rj类资源的（最大数目为K）
		
	3、分配矩阵：Allocation
		是一个n * m矩阵，定义了系统（每一类当前资源）已分配给（每一进程的资源数）
		例如：Allocation[i, j] = K, 进程i当前，已分得Rj类资源的数目为K个
	
	4、需求矩阵Need。
		是一个n * m的矩阵， 用来表示每一个进程需要各类资源数
		例如：Need[i, j] = k, 表示进程i还需要Rj类资源的K个，放能完成任务
~~~

- 银行家算法

![image-20210112081752363](https://gitee.com/sheep-are-flying-in-the-sky/my-picture/raw/master/picture6/image-20210112081752363.png)



- 安全性算法

![image-20210112083013431](https://gitee.com/sheep-are-flying-in-the-sky/my-picture/raw/master/picture6/image-20210112083013431.png)



- 参考文档

> 参考博客1：
>
> https://blog.csdn.net/hd12370/article/details/82814348?utm_medium=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromBaidu-1.control&depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromBaidu-1.control

> 参考博客2：
>
> https://blog.csdn.net/yanxiaolx/article/details/51944048?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2.control&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2.control



- 习题一

![image-20210112084340490](https://gitee.com/sheep-are-flying-in-the-sky/my-picture/raw/master/picture6/image-20210112084340490.png)

~~~
【解】能。  request0(0,1,0)≤need0(7,4,3);request0(0,1,0)≤available(2,3,0); 系统暂时先假定可为P0分配资源，并修改有关数据，如下所示：         
       	allocation       need       available         
   		  A  B  C       A  B  C    	 A  B  C      
     P0   0  2  0       7  3  3      2  2  0     
     P1   3  0  2       0  2  0      
     P2   3  0  2       6  0  0      
     P3   2  1  1       0  1  1     
     P4   0  0  2       4  3  1  
存在一个安全序列{P1,P3,P0,P2,P4}，故系统是安全的，可以分配资源。

~~~





- 习题二

![image-20210112084416830](https://gitee.com/sheep-are-flying-in-the-sky/my-picture/raw/master/picture6/image-20210112084416830.png)

~~~
遵循：能吃大鱼和小鱼时， 先吃小鱼
	 切记：每一组是分开的
【解】（1）利用安全性算法对上面的状态进行分析（见下表），找到了一个安全序列{P0,P3,P4,P1,P2}，故系统是安全的。   
       Work       Need    Allocation     Work+Allocation          Finish 
P0   1 6 2 2    0 0 1 2    0 0 3 2        1  6   5   4             true
P3   1 6 5 4    0 6 5 2    0 3 3 2        1  9   8   6             true 
P4   1 9 8 6    0 6 5 6    0 0 1 4        1  9   9   10            true 
P1   1 9 9 10   1 7 5 0    1 0 0 0        2  9   9   10            true 
P2   2 9 9 10   2 3 5 6    1 3 5 4        3  12  14  14            true 
（2）P2发出请求向量Request(1,2,2,2),系统按银行家算法进行检查：
     ①Request2(1,2,2,2)<=Need2(2,3,5,6) 
     ②Request2(1,2,2,2)<=Available(1,6,2,2)  
     ③系统先假定可为P2分配资源，并修改Available，
      Allocation2和Need2向量：Available=(0,4,0,0)      
 	  Allocation2=(2,5,7,6)      
      Need2=(1,1,3,4) 
     ④进行安全性检查：此时对于所有的进程，条件Needi≤Available(0,4,0,0)都不成立，
      即Available不能满足任何进程的请求，故系统进入不安全状态。
      因此，当进程P2提出Request(1,2,2,2)后，系统不能将资源分配给它。

~~~

- 死锁定理（资源分配图）

<img src="https://gitee.com/sheep-are-flying-in-the-sky/my-picture/raw/master/picture6/image-20210112095043782.png" alt="image-20210112095043782" style="zoom:50%;" />



## 2.4、进程同步

~~~

~~~

![image-20210112100653390](https://gitee.com/sheep-are-flying-in-the-sky/my-picture/raw/master/picture6/image-20210112100653390.png)

## 2.5、段页式存储管理方式

~~~

~~~



## 2.6、分时系统

~~~

~~~



## 2.7、SPOOLING技术

~~~

~~~



## 2.8、页面置换算法

~~~

~~~



## 2.9、“抖动”与工作集

~~~

~~~



## 2.10、请求分页存储管理方式

~~~

~~~



## 2.11、作业与作业调度

~~~

~~~



## 2.12、处理机调度的层次

~~~

~~~



## 2.13、存储器的层次结构

~~~

~~~



## 2.14、连续分配存储管理方式

~~~

~~~



## 2.15、高优先权优先调度算法

~~~

~~~



