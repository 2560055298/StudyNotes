# 1、c51语法

## 1.1、头文件

~~~c
#include <reg51.h>			//定义了：端口地址
~~~



## 1.2、sbit

~~~
sbit是定义（特殊功能寄存器）的（位变量）。
bit和sbit都是C51扩展的变量类型。
典型应用是：sbit P0_0=P0^0;//即定义P0_0为P0口的第1位，以便进行位操作。
bit和int char之类的差不多，只不过char=8位, bit=1位而已。
都是变量，编译器在编译过程中分配地址。
~~~



## 1.3、code

> 相当于：常量

![image-20210312161542756](https://gitee.com/sheep-are-flying-in-the-sky/my-picture/raw/master/picture8/image-20210312161542756.png)****



# 2、实战

> 类似于：Hello World

## 2.1、让一盏小灯亮

### 2.2.1、先上结果图

> 注意：合适（阻值）

<img src="https://gitee.com/sheep-are-flying-in-the-sky/my-picture/raw/master/picture8/image-20210312100037469.png" alt="image-20210312100037469" style="zoom:50%;" />



### 2.2.2、代码

> keil：12HZ， 输出main.hex文件

~~~c
#include <reg51.h>		//包含了各个引脚的地址

//类型sbit, P20变量名， P2^0 P2的第一个地址P2.0
//这就句话：就是给P20绑定一个地址, 也就是（51单片机上P2.0的地址）
sbit P20 = P2^0;	
					
void main(){
	while(1){
		//将该P2.0的值：置位0
		P20 = 0;
	}
}					  	
~~~



## 2.2、51单片机最小系统

~~~
1、51单片机
2、电源地
3、晶振
4、RET
~~~

> 电容：换算公式
>
> 1法拉(F) = 1×10^6微法(μF)
>
> 1微法(μF)=1X10^3纳法(nF)
>
> 1纳法(nF)(μF)= 1×10^3皮法（pF）

<img src="https://gitee.com/sheep-are-flying-in-the-sky/my-picture/raw/master/picture8/image-20210312103752613.png" alt="image-20210312103752613" style="zoom:50%;" />

---



## 2.3、流水灯

~~~
要求：
      编程控制单片机驱动八个led灯花样点亮。点亮方式为重复以下（1）至（4）步。
        （1）先由上至下依次点亮两轮，每次只亮一盏；
        （2） 接着所有灯交错点亮（亮灭亮灭亮灭亮灭）两轮；
        （3）然后由下至上依次点亮两轮，每次只亮一盏；
        （4）最后所有灯全闪全灭两轮。       
~~~

### 2.3.1、结果图

![image-20210312144926489](https://gitee.com/sheep-are-flying-in-the-sky/my-picture/raw/master/picture8/image-20210312144926489.png)

### 2.3.2、代码

~~~c
#include <reg51.h>

char code led[8] = {0xfe, 0xfd, 0xfb, 0xf7, 0xef, 0xdf, 0xbf, 0x7f};

//延时：函数
void delay(int ms){
	int i, j;
	for(i = 0; i < ms; i++){
		for(j = 0; j < 120; j++){}	
	}
}

void main(){		   
	while(1){
	   int i, j;

	   //第一步：先由上至下，点亮两轮， 每次只亮一盏
	   for(i = 0; i < 2; i++){
		   	 for(j = 0; j < 8; j++){
		   	  P2 = led[j];
			  delay(300);
		   	}
	   }

	   //第二步：所有灯交错点亮
	   for(i = 0; i < 2; i++){
	   		P2 = 0xAA;
			delay(600);
			P2 = 0xFF;
			delay(600);
	   }

	   //第三步：由下依次点亮两轮， 每次只亮一盏
	   for(i = 0; i < 2; i++){
	   		for(j = 7; j >= 0; j--){
		   	  P2 = led[j];
			  delay(300);
		   	}
	   }

	   //第四步：全闪、全灭 （进行两轮）
	   for(i = 0; i < 2; i++){
	   		P2 = 0x00;
			delay(600);
			P2 = 0xFF;
			delay(600);	
	   }
	}
}
~~~



### 2.3.3、分析

> 需要：知道char code 存储的是（8位长度的地址）
>
> 0xfe  相当于 P2.7~P2.0  ==>> 1111 1110
>
> 因为，阳极接的是（小灯正）， 所以P2接口，为0时，形成`闭合回路`, 小灯（亮起）





## 2.4、数码管

> 显示：数字1~8

### 2.4.1、数码管：原理图

<img src="https://gitee.com/sheep-are-flying-in-the-sky/my-picture/raw/master/picture8/image-20210312150723705.png" alt="image-20210312150723705" style="zoom: 50%;" />

---

### 2.4.2、运行结果图

<img src="https://gitee.com/sheep-are-flying-in-the-sky/my-picture/raw/master/picture8/image-20210312171353448.png" alt="image-20210312171353448" style="zoom:67%;" />

### 2.4.3、代码

~~~c
#include <reg51.h>

//定义：0~8的P存放的8位数据
char code led[9] = {0xc0, 0xf9, 0xa4, 0xb0, 0x99, 0x92, 0x83, 0xf8, 0x80};


/*
	这是：0~8位数字的（地址）
	1100 0000	:0xc0   -->0
	1111 1001 :0xf9		-->1
	1010 0100 :0xa4		-->2
	
	1011 0000 :0xb0		-->3
	1001 1001 :0x99		-->4
	1001 0010 :0x92		-->5
	1000 0011 :0x83		-->6
	1111 1000 :0xf8		-->7
	1000 0000 :0x80		-->8
	
*/
	
//延迟函数
void delay(unsigned int ms){
	int i, j;
	for(i = 0; i < ms; i++){
		for(j = 0; j < 125; j++);
	}
}
	
void main(){	
	while(1){
		int i;
		
		//通过循环：进行遍历
		for(i = 0; i < 9; i++){
			P2 = led[i];
			delay(500);
		}
	}
}
~~~